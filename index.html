<!DOCTYPE html>
<html>
<head>
    <style>
        .container {
            width: 900px;
            height: 506px;
            position: relative;
            margin: 20px auto;
            overflow: hidden;
            border: 2px solid #333;
        }

        .tetris-piece {
            position: absolute;
            background-image: url('PP.jpg'); /* βάλε εδώ το σωστό path προς την εικόνα */
            background-size: 900px 506px;
            transition: transform 1s cubic-bezier(0.4, 0, 0.2, 1), opacity 1s;
            opacity: 0;
        }

        button {
            display: block;
            margin: 10px auto;
            padding: 10px 20px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="container" id="puzzleContainer"></div>
    <button id="stopBtn">STOP</button>

    <!-- Ορισμός SVG clipPaths για σχήματα Tetris -->
    <svg width="0" height="0">
        <clipPath id="I-shape">
            <rect width="200" height="50"/>
        </clipPath>
        <clipPath id="T-shape">
            <path d="M0,0 L150,0 L150,50 L100,50 L100,100 L50,100 L50,50 L0,50 Z"/>
        </clipPath>
        <clipPath id="L-shape">
            <path d="M0,0 L50,0 L50,150 L0,150 Z"/>
        </clipPath>
        <clipPath id="O-shape">
            <rect width="100" height="100"/>
        </clipPath>
        <clipPath id="line-shape">
            <rect width="300" height="50"/>
        </clipPath>
    </svg>

    <script>
        // Διάταξη κομματιών για 900x506px
        const STATIC_LAYOUT = [
            // Γραμμή 1
            { type: 'I',    x: 0,   y: 0,   width: 200, height: 50  },
            { type: 'T',    x: 200, y: 0,   width: 150, height: 100 },
            { type: 'O',    x: 350, y: 0,   width: 100, height: 100 },
            { type: 'line', x: 450, y: 0,   width: 300, height: 50  },
            
            // Γραμμή 2
            { type: 'L',    x: 0,   y: 100, width: 50,  height: 150 },
            { type: 'O',    x: 50,  y: 100, width: 100, height: 100 },
            { type: 'I',    x: 150, y: 100, width: 200, height: 50  },
            { type: 'T',    x: 350, y: 100, width: 150, height: 100 },
            
            // Γραμμή 3
            { type: 'line', x: 0,   y: 250, width: 300, height: 50  },
            { type: 'L',    x: 300, y: 250, width: 50,  height: 150 },
            { type: 'O',    x: 350, y: 250, width: 100, height: 100 },
            { type: 'I',    x: 450, y: 250, width: 200, height: 50  },
            
            // Γραμμή 4
            { type: 'line', x: 0,   y: 456, width: 900, height: 50  }
        ];

        let animationActive = true;
        let pieces = [];

        function initializePuzzle() {
            const container = document.getElementById('puzzleContainer');
            
            STATIC_LAYOUT.forEach(config => {
                const piece = document.createElement('div');
                piece.className = 'tetris-piece';
                
                // Ορισμός εμφάνισης και τελικής θέσης
                Object.assign(piece.style, {
                    width: `${config.width}px`,
                    height: `${config.height}px`,
                    left: `${config.x}px`,
                    top: `${config.y}px`,
                    clipPath: `url(#${config.type}-shape)`,
                    backgroundPosition: `-${config.x}px -${config.y}px`
                });

                container.appendChild(piece);
                pieces.push(piece);
            });
        }

        function dropPieces() {
            // 1) Κάνουμε όλα τα κομμάτια αρχικά "κρυφά" πιο πάνω από το container
            pieces.forEach(piece => {
                // Απενεργοποιούμε το transition για να το τοποθετήσουμε αρχικά
                piece.style.transition = 'none';
                // Βάζουμε το κομμάτι πολύ πιο πάνω (π.χ. -600px) ώστε να «πέφτει» μετά
                piece.style.transform = `translateY(-600px)`;
                piece.style.opacity = '0';
            });

            // Αφήνουμε ένα frame να περάσει (για να «γράψει» το αρχικό state)
            requestAnimationFrame(() => {
                // 2) Σε κάθε κομμάτι, μετά από μικρή καθυστέρηση, ενεργοποιούμε την πτώση
                pieces.forEach((piece, index) => {
                    // Μικρή τυχαία οριζόντια απόκλιση (προαιρετικά)
                    const randomOffsetX = -50 + Math.random() * 100;

                    // Επαναφέρουμε το transition
                    piece.style.transition = 'transform 1s cubic-bezier(0.4, 0, 0.2, 1), opacity 1s';

                    // Μετά από κάποια καθυστέρηση (π.χ. 200ms * index), το «ρίχνουμε»
                    setTimeout(() => {
                        if (!animationActive) return; // Αν πατηθεί STOP ενδιάμεσα
                        
                        // Ορίζουμε το κομμάτι να εμφανιστεί και να μετακινηθεί
                        piece.style.opacity = '1';
                        // Από την τυχαία X απόκλιση και -600px, πηγαίνει στη σωστή του θέση (0,0)
                        piece.style.transform = `translate(${randomOffsetX}px, 0)`;
                    }, 200 * index);
                });
            });
        }

        function stopAnimation() {
            animationActive = false;
            // Προαιρετικά, μπορείς να «παγώσεις» τα κομμάτια όπως είναι.
            // Π.χ. pieces.forEach(piece => piece.style.transition = 'none');
        }

        document.getElementById('stopBtn').addEventListener('click', stopAnimation);

        window.onload = () => {
            initializePuzzle();
            dropPieces();
        };
    </script>
</body>
</html>
