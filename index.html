<!DOCTYPE html>
<html lang="el">
<head>
  <meta charset="UTF-8">
  <title>Tetris Puzzle</title>
  <style>
    .container {
      width: 900px;
      height: 506px; /* Στην πράξη χρησιμοποιούμε 500px για να ταιριάζουν τα κομμάτια */
      position: relative;
      margin: 20px auto;
      overflow: hidden;
      border: 2px solid #333;
      background-color: #f0f0f0;
    }

    .tetris-piece {
      position: absolute;
      background-image: url('PP.jpg'); /* Προσαρμόστε το path εάν χρειάζεται */
      background-size: 900px 506px;    /* Για να ταιριάζει με το container */
      opacity: 0;                      /* Ξεκινάει αόρατο */
      /* Το transition θα το ορίσουμε δυναμικά σε JS, ανάλογα με το κομμάτι */
    }

    button {
      display: block;
      margin: 10px auto;
      padding: 10px 20px;
      cursor: pointer;
    }
  </style>
</head>
<body>

  <div class="container" id="puzzleContainer"></div>
  <button id="stopBtn">STOP</button>

  <script>
    /*
      Στατικό layout για 5 μεγάλες λωρίδες των 900x100, 
      που καλύπτουν 900x500 (αγνοώντας τα τελευταία 6px ύψους).
      Θα πέφτουν από κάτω προς τα πάνω:
        - index 0 => y=400..500 (κάτω λωρίδα)
        - index 1 => y=300..400
        - ...
        - index 4 => y=0..100 (κορυφή)
    */
    const STATIC_LAYOUT = [
      { x: 0, y: 400, width: 900, height: 100 },
      { x: 0, y: 300, width: 900, height: 100 },
      { x: 0, y: 200, width: 900, height: 100 },
      { x: 0, y: 100, width: 900, height: 100 },
      { x: 0, y:   0, width: 900, height: 100 }
    ];

    let animationActive = true;
    let pieces = [];

    // 1) Φτιάχνουμε τα κομμάτια και τα βάζουμε στις σωστές συντεταγμένες (left/top).
    function initializePuzzle() {
      const container = document.getElementById('puzzleContainer');

      STATIC_LAYOUT.forEach(config => {
        const piece = document.createElement('div');
        piece.className = 'tetris-piece';

        // Στιλ για το κομμάτι: διαστάσεις + θέση + "φέτα" από την εικόνα
        Object.assign(piece.style, {
          width:  config.width  + 'px',
          height: config.height + 'px',
          left:   config.x      + 'px',
          top:    config.y      + 'px',
          // Ρυθμίζουμε το backgroundPosition ώστε να δείχνει το σωστό κομμάτι της PP.jpg
          backgroundPosition: `-${config.x}px -${config.y}px`
        });

        container.appendChild(piece);
        pieces.push(piece);
      });
    }

    // 2) Λογική «πτώσης» των κομματιών. Ξεκινάμε από το χαμηλότερο (index=0) προς το υψηλότερο.
    function dropPieces() {
      // Αρχικά τοποθετούμε όλα τα κομμάτια πολύ ψηλά (off-screen), ώστε να «πέφτουν» μετά
      pieces.forEach(piece => {
        piece.style.transform = 'translateY(-600px)'; // εκτός οθόνης
        piece.style.opacity   = '0';
        // Απενεργοποιούμε το transition αρχικά, για να μην κινούνται ακόμα
        piece.style.transition = 'none';
      });

      // Αφήνουμε ένα frame να περάσει για να «γράψει» το αρχικό state
      requestAnimationFrame(() => {

        // Ρίχνουμε τα κομμάτια **από κάτω προς τα πάνω** (index 0 -> 1 -> 2 κ.λπ.)
        pieces.forEach((piece, index) => {
          // Θέλουμε το χαμηλότερο (index=0) να πέφτει με μεγαλύτερη διάρκεια,
          // και το υψηλότερο (index=4) με μικρότερη.
          // Π.χ. duration = 3.5 - 0.5*index (3.5s, 3s, 2.5s, 2s, 1.5s)
          const duration = 3.5 - index * 0.5;

          // Χρόνος αναμονής (delay) πριν καν ξεκινήσει η πτώση
          // ώστε να πέφτουν διαδοχικά και όχι όλα μαζί.
          // Π.χ. 1.5s * index
          const delay = 1500 * index;

          // Ενεργοποιούμε το transition για κάθε κομμάτι ξεχωριστά
          piece.style.transition = `transform ${duration}s ease, opacity 1s`;

          // Προγραμματίζουμε το "πέσιμο" μετά το delay
          setTimeout(() => {
            if (!animationActive) return; // Αν πατήθηκε STOP, μην συνεχίσεις

            piece.style.opacity   = '1';
            piece.style.transform = 'translateY(0)'; 
            // Από το -600px στο 0, δηλαδή στην τελική του θέση.
          }, delay);
        });
      });
    }

    // 3) Πατάμε STOP για να σταματήσουμε την πτώση των επόμενων κομματιών
    function stopAnimation() {
      animationActive = false;
      // (Προαιρετικά, αν θέλεις να "παγώσεις" κιόλας τα ήδη κινούμενα κομμάτια:
      // pieces.forEach(p => p.style.transition = 'none');
      // )
    }

    // 4) Δέσμες ενεργειών στο φόρτωμα
    window.onload = () => {
      initializePuzzle();
      dropPieces();

      document.getElementById('stopBtn').addEventListener('click', stopAnimation);
    };
  </script>
</body>
</html>
