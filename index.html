<!DOCTYPE html>
<html>
<head>
    <style>
        .container {
            width: 900px;
            height: 504px; /* Προσαρμογή για ακέραιο πολλαπλάσιο */
            position: relative;
            margin: 20px auto;
            overflow: hidden;
            border: 2px solid #333;
            background: #f0f0f0;
        }

        .tetris-piece {
            position: absolute;
            background-image: url('PP.jpg');
            background-size: 900px 504px;
            transition: transform 1.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
    </style>
</head>
<body>
    <div class="container" id="puzzleContainer"></div>
    <button id="stopBtn">STOP</button>

    <svg width="0" height="0">
        <!-- Tetris Blocks -->
        <clipPath id="I-shape">
            <rect width="100" height="25"/>
        </clipPath>
        <clipPath id="T-shape">
            <path d="M0,0 L100,0 L100,25 L70,25 L70,50 L30,50 L30,25 L0,25 Z"/>
        </clipPath>
        <clipPath id="L-shape">
            <path d="M0,0 L75,0 L75,50 L25,50 L25,25 L0,25 Z"/>
        </clipPath>
        <clipPath id="O-shape">
            <rect width="50" height="50"/>
        </clipPath>
    </svg>

    <script>
        const BLOCK_SIZE = 50;
        const COLS = 18;  // 900 / 50
        const ROWS = 10;  // 500 / 50
        const TETROMINOES = {
            'I': [[1,1,1,1]],
            'O': [[1,1],[1,1]],
            'T': [[0,1,0],[1,1,1]],
            'L': [[1,0],[1,0],[1,1]]
        };

        class PuzzleTiler {
            constructor() {
                this.grid = Array(ROWS).fill().map(() => Array(COLS).fill(0));
                this.pieces = [];
            }

            generatePieces() {
                for(let shape in TETROMINOES) {
                    while(this.placeShape(TETROMINOES[shape])) {}
                }
            }

            placeShape(shape) {
                // Πιθανές θέσεις και περιστροφές
                for(let rotation = 0; rotation < 4; rotation++) {
                    const rotated = this.rotate(shape, rotation);
                    for(let y = 0; y < ROWS - rotated.length + 1; y++) {
                        for(let x = 0; x < COLS - rotated[0].length + 1; x++) {
                            if(this.canPlace(rotated, x, y)) {
                                this.markGrid(rotated, x, y);
                                this.pieces.push({ shape: rotated, x, y });
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            rotate(matrix, times) {
                // Περιστροφή πίνακα
                let result = matrix;
                for(let i = 0; i < times; i++) {
                    result = result[0].map((_, i) => 
                        result.map(row => row[row.length-1-i])
                    );
                }
                return result;
            }

            canPlace(shape, x, y) {
                // Έλεγχος εάν χωράει το σχήμα
                for(let dy = 0; dy < shape.length; dy++) {
                    for(let dx = 0; dx < shape[dy].length; dx++) {
                        if(shape[dy][dx] && this.grid[y+dy][x+dx]) return false;
                    }
                }
                return true;
            }

            markGrid(shape, x, y) {
                for(let dy = 0; dy < shape.length; dy++) {
                    for(let dx = 0; dx < shape[dy].length; dx++) {
                        if(shape[dy][dx]) this.grid[y+dy][x+dx] = 1;
                    }
                }
            }
        }

        // Αρχικοποίηση και δημιουργία κομματιών
        const tiler = new PuzzleTiler();
        tiler.generatePieces();
        console.log(tiler.pieces); // Debug: Προβολή δημιουργημένων κομματιών

        // ... (Υπόλοιπος κώδικας για animation και διαχείριση)
    </script>
</body>
</html>
